#include "../control_ports.def"
#include "../../cpu-68000/kernel-68000.def"

	.globl __end
	.globl __bss_start
	.globl start
	.globl  cpu_type

.section .rom_header, "ax", @progbits
#==============================================================
# CPU VECTOR TABLE
#==============================================================
# This must be the very first thing in the ROM, since the CPU
# reads it from 0x0000 on bootup.
#==============================================================
.set udata_block_end, udata_block + UBLOCK_SIZE
	.long   udata_block_end			| Initial stack pointer value
	.long   CPU_EntryPoint			| Start of program
	.long   e_bus_error 			| Bus error
	.long   e_addr_error 			| Address error

	.long   rom_illegal				| Division by zero
	.long   e_divzero				| Illegal instruction
	.long   e_chk					| CHK CPU_Exception
	.long   e_trapv					| TRAPV CPU_Exception

	.long   e_priv					| Privilege violation
	.long   e_trace				| TRACE exception
	.long   e_unimpa				| Line-A emulator
	.long   e_unimpf				| Line-F emulator

	.long   e_unexpected				| Unused (reserved)
	.long   e_unexpected				| Unused (reserved)
	.long   e_unexpected				| Unused (reserved)
	.long   e_uninit				| Unused (reserved)

	| 16-23 unused
	.long   e_unexpected				| Unused (reserved)
	.long   e_unexpected				| Unused (reserved)
	.long   e_unexpected				| Unused (reserved)
	.long   e_unexpected				| Unused (reserved)
	.long   e_unexpected				| Unused (reserved)
	.long   e_unexpected				| Unused (reserved)
	.long   e_unexpected				| Unused (reserved)
	.long   e_unexpected				| Unused (reserved)

	| 24
	.long   e_spurious				| Spurious exception
	.long   interrupt				| IRQ level 1
	.long   e_unexpected				| IRQ level 2
	.long   e_unexpected				| IRQ level 3
	.long   INT_HInterrupt		| IRQ level 4 (horizontal retrace interrupt)
	.long   e_unexpected  			| IRQ level 5
	.long   INT_VInterrupt		| IRQ level 6 (vertical retrace interrupt)
	.long   e_unexpected				| IRQ level 7

	| 32 - TRAP #n
	.long   e_trap0				| TRAP #00 exception
	.long   e_trap1				| TRAP #01 exception
	.long   e_trap2				| TRAP #02 exception
	.long   e_trap3				| TRAP #03 exception
	.long   e_trap4				| TRAP #04 exception
	.long   e_trap5				| TRAP #05 exception
	.long   e_trap6				| TRAP #06 exception
	.long   e_trap7				| TRAP #07 exception
	.long   e_trap8				| TRAP #08 exception
	.long   e_trap9				| TRAP #09 exception
	.long   e_trap10				| TRAP #10 exception
	.long   e_trap11				| TRAP #11 exception
	.long   e_trap12				| TRAP #12 exception System call
	.long   e_trap13				| TRAP #13 exception
	.long   e_trap14				| TRAP #14 exception
	.long   e_trap15				| TRAP #15 exception

	| unused
	.long   e_unexpected				| Unused (reserved)
	.long   e_unexpected				| Unused (reserved)
	.long   e_unexpected				| Unused (reserved)
	.long   e_unexpected				| Unused (reserved)
	.long   e_unexpected				| Unused (reserved)
	.long   e_unexpected				| Unused (reserved)
	.long   e_unexpected				| Unused (reserved)
	.long   e_unexpected				| Unused (reserved)
	.long   e_unexpected				| Unused (reserved)
	.long   e_unexpected				| Unused (reserved)
	.long   e_unexpected				| Unused (reserved)
	.long   e_unexpected				| Unused (reserved)
	.long   e_unexpected				| Unused (reserved)
	.long   e_unexpected				| Unused (reserved)
	.long   e_unexpected				| Unused (reserved)
	.long   e_unexpected				| Unused (reserved)
	
#==============================================================
# SEGA MEGA DRIVE ROM HEADER
#==============================================================
# A structure that specifies some metadata about the ROM, like
# its name, author, version number, release date, region,
# and any special peripherals used.
# Note that the Mega Drive console itself doesn't read any of
# this, it's more a convenience for the programmer, but
# most emulators will read the title and region.
#==============================================================
# If your emulator doesn't show the correct ROM name, then this
# table is in the wrong place or in the wrong format.
#==============================================================
.set rom_end_address, _ROM_End - 1
	.ascii "SEGA MEGA DRIVE "    | Console name
	.ascii "eythore         "    | Copyright holder and release date
	.ascii "WozMon          "	 | 0x120 48 bytes | Game title (domestic)
	.ascii "                "
	.ascii "                " 
	.ascii "WozMon          "	 | 0x150 48 bytes | Game title (overseas)
	.ascii "                "
	.ascii "                " 
	.ascii "GM XXXXXXXX-XX"      | Version number
	.word 0x0000                 | Checksum
	.ascii "J               "    | I/O support
	.long _ROM_Start             | Start address of ROM
	.long rom_end_address        | End address of ROM
	.long 0x00FF0000             | Start address of RAM
	.long 0x00FFFFFF             | End address of RAM
	.long 0x00000000             | SRAM enabled
	.long 0x00000000             | Unused
	.long 0x00000000             | Start address of SRAM
	.long 0x00000000             | End address of SRAM
	.long 0x00000000             | Unused
	.long 0x00000000             | Unused
	.ascii "                                        " | Notes (unused)
	.ascii "  E             "    | Country codes


    .section .text
    .globl CPU_EntryPoint, INT_VInterrupt, INT_HInterrupt
#==============================================================
# INTERRUPT ROUTINES
#==============================================================
# The interrupt routines, as specified in the vector table in
# the rom_header.
# Note that we use RTE to return from an interrupt, not
# RTS like a subroutine.
#==============================================================

# Vertical interrupt - run once per frame
INT_VInterrupt:
	rte

# Horizontal interrupt - run once per N scanlines (N = specified in VDP register $A)
INT_HInterrupt:
	rte

# # Exception interrupt - called if an error has occured
# CPU_Exception:
#	# Just halt the CPU if an error occurred. Later on, we may want to write
#	# an exception handler to draw the current state of the machine to screen
#	# (registers, stack, error type, etc) to help debug the problem.
#	stop   #0x2700
#	rte

#==============================================================
# Initialise the Mega Drive
#==============================================================

CPU_EntryPoint:
	#==============================================================
	# Initialise the Mega Drive
	#==============================================================

	# Write the TMSS signature (if a model 1+ Mega Drive)
	jsr    VDP_WriteTMSS

	# Load the initial VDP registers
	jsr    VDP_LoadRegisters


	jsr VDP_ClearVRAM
	
	#==============================================================
	# Initialise status register and set interrupt level.
	# This begins firing vertical and horizontal interrupts.
	#==============================================================
	move.w #0x2300,%sr

	#==============================================================
	#  Write color pallete to cram
	#==============================================================
	jsr VDP_writePallete

	#==============================================================
	# Write the font tiles to VRAM
	#==============================================================
	jsr fontInit

    jsr initKeyboard  


start:
		or #$0700,%sr
		move.l #_etext,%a0
		move.l #_data,%a1
		move.l #_edata,%d0
		sub.l  #_data,%d0
		lsr.w #2,%d0
dcopy:
		; We may copy a byte or two extra doesn't matter
		; as the BSS clear happens next
		move.l (%a0)+,(%a1)+
		dbra.w %d0,dcopy

		move.l #__bss_start,a0
		move.l #__end,d0
		sub.l %a0,%d0
		lsr.l #2,%d0
wipebss:
		clr.l (%a0)+
		dbra %d0,wipebss

		bsr init_early
		bsr init_hardware
		bsr fuzix_main
		or #$0700,%sr
stop:		bra stop

rom_illegal:
		tst.b cpuprobe
		bne cpu_type_exit
		jmp e_illegal

;
;	FIXME: doesn't tell 68020 from 68030
;	One way we could do that would be to issue a CALLM with a bogus
;	module descriptor and see if we get illegal (68030) or a format
;	exception. We can fix that when we actually need to support anything
;	bigger than a 68010 !
;
;	Based on the core code one except that we have to handle ROM
;	vectors.
;
cpu_type:
		move.w %sr,-(%sp)
		move #$2700,%sr		; disable interrupts
		move.b #1,cpuprobe
		move.l %a7,%a1
		moveq #0,%d0
		save
		chip 68010
		movec vbr,%d1		; faults on a 68000
		moveq #10,%d0
		chip 68020
		movec cacr,%d1		; faults on a 68000 and 010
		move.b #1,cpu_has_icache
		moveq #20,%d0
		chip 68040
		movec itt0,%d1		; faults on 68020/30
		moveq #40,%d0
		chip 68060
		movec pcr,%d1		; faults on all but 68060
		moveq #60,%d0
		clr.b cpuprobe
		restore
cpu_type_exit:
		move.l %a1,%a7
		clr.b cpuprobe
		move.b %d0,cpu_has_trapvec
		move (%sp)+,%sr
		rts

.area data

cpuprobe:	byte 0

