#==============================================================
# VDP Commands
#==============================================================
    .equ vdp_cmd_vram_write,  0x40000000
    .equ vdp_cmd_vram_read,   0x00000000
    .equ vdp_cmd_cram_write,  0xC0000000
    .equ vdp_cmd_cram_read,   0x00000020
    .equ vdp_cmd_vsram_write, 0x40000010   | Vertical Scroll RAM address

#==============================================================
# VDP Memory Addresses
# According to VDP registers 0x2 and 0x4 (see table above)
#==============================================================
    .equ vram_addr_tiles,     0x0000
    .equ vram_addr_plane_a,   0xC000
    .equ vram_addr_plane_b,   0xE000

#==============================================================
# Screen Width and Height (in pixels)
#==============================================================
    .equ vdp_screen_width,    0x0140
    .equ vdp_screen_height,   0x00F0

#==============================================================
# The Plane Width and Height (in tiles)
# According to VDP register 0x10 (see table above)
#==============================================================
    .equ vdp_plane_width,     0x40
    .equ vdp_plane_height,    0x20

#==============================================================
# The Size of a Word and Longword
#==============================================================
    .equ size_word,           2
    .equ size_long,           4

#==============================================================
# The Size of One Palette (in bytes, words, and longwords)
#==============================================================
    .equ size_palette_b,      0x20
    .equ size_palette_w,      size_palette_b / size_word
    .equ size_palette_l,      size_palette_b / size_long

#==============================================================
# The Size of One Graphics Tile (in bytes, words, and longwords)
#==============================================================
    .equ size_tile_b,         0x20
    .equ size_tile_w,         size_tile_b / size_word
    .equ size_tile_l,         size_tile_b / size_long


#==============================================================
# Initialise the Mega Drive
#==============================================================
    .section .text
    .globl CPU_EntryPoint, CPU_Exception, INT_VInterrupt, INT_HInterrupt, INT_Null


CPU_EntryPoint:
	#==============================================================
	# Initialise the Mega Drive
	#==============================================================

	# Write the TMSS signature (if a model 1+ Mega Drive)
	jsr    VDP_WriteTMSS

	# Load the initial VDP registers
	jsr    VDP_LoadRegisters


	jsr VDP_ClearVRAM
	
	#==============================================================
	# Initialise status register and set interrupt level.
	# This begins firing vertical and horizontal interrupts.
	#==============================================================
	move.w #0x2300,%sr

	#==============================================================
	#  Write color pallete to cram
	#==============================================================
	jsr VDP_writePallete

	#==============================================================
	# Write the font tiles to VRAM
	#==============================================================
	jsr fontInit

    jsr initKeyboard  

    jmp _start



#==============================================================
# INTERRUPT ROUTINES
#==============================================================
# The interrupt routines, as specified in the vector table in
# the rom_header.
# Note that we use RTE to return from an interrupt, not
# RTS like a subroutine.
#==============================================================

# Vertical interrupt - run once per frame
INT_VInterrupt:
	rte

# Horizontal interrupt - run once per N scanlines (N = specified in VDP register $A)
INT_HInterrupt:
	rte

# NULL interrupt - for interrupts we don't care about
INT_Null:
	rte

# Exception interrupt - called if an error has occured
CPU_Exception:
	# Just halt the CPU if an error occurred. Later on, we may want to write
	# an exception handler to draw the current state of the machine to screen
	# (registers, stack, error type, etc) to help debug the problem.
	stop   #0x2700
	rte
